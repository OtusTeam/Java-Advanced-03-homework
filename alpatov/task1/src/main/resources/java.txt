Java
Материал из Википедии — свободной энциклопедии
Текущая версия страницы пока не проверялась опытными участниками и может значительно отличаться от версии, проверенной 28 сентября 2023 года; проверки требуют 28 правок.
Эта статья — о языке программирования. О прикладной платформе на основе данного языка см. Java (программная платформа).
Не следует путать с JavaScript.
Java

Класс языка
язык JVM, мультипарадигменный: объектно-ориентированный, аспектно-ориентированный,

обобщённый, рефлективный
Появился в	1995
Автор	Джеймс Гослинг и Sun Microsystems
Разработчик	Sun Microsystems и Oracle[1]
Расширение файлов	.java, .class, .jar, .jad, .jmod, .war, .ear
Выпуск	Java SE 22[2] (19.03.2024)
Испытал влияние	C++, Си, Ада, Simula 67[d], Smalltalk, Objective-C, Object Pascal, Оберон, Eiffel, Модула-3, Mesa[d], Симула, C#, UCSD Pascal, обёртка[d], Вариативная функция, аннотация Java, Никлаус Вирт, Патрик Нотон[вд] и foreach[d]
Повлиял на	Ada, C#, Chapel, Clojure, ECMAScript, Fantom, Gambas, Groovy, Hack, Haxe, J#, Kotlin, PHP, Python, Scala, Seed7, Vala, JavaScript
Лицензия	GNU GPL[3]
Сайт	oracle.com/ru/java/
Логотип Викисклада Медиафайлы на Викискладе
Java[прим. 1] — строго типизированный объектно-ориентированный язык программирования общего назначения, разработанный компанией Sun Microsystems (в последующем приобретённой компанией Oracle). Разработка ведётся сообществом, организованным через Java Community Process; язык и основные реализующие его технологии распространяются по лицензии GPL. Права на торговую марку принадлежат корпорации Oracle.

Приложения Java обычно транслируются в специальный байт-код, поэтому они могут работать на любой компьютерной архитектуре, для которой существует реализация виртуальной Java-машины. Дата официального выпуска — 23 мая 1995 года. Java занимает высокие места в рейтингах популярности языков программирования (2-е место в рейтингах IEEE Spectrum (2020)[4] и TIOBE (2021[5]).


Содержание
1	История создания
2	Основные особенности языка
3	История версий
3.1	JDK 1.0
3.2	JDK 1.1
3.3	J2SE 1.2
3.4	J2SE 1.3
3.5	J2SE 1.4
3.6	J2SE 5.0
3.7	Java SE 6
3.8	JavaFX
3.9	Java ME Embedded
3.10	Java SE 7
3.10.1	Список нововведений
3.11	Java SE 8
3.11.1	Список нововведений
3.12	Java SE 9
3.12.1	Список нововведений
3.13	Java SE 10
3.13.1	Список нововведений
3.14	Java SE 11
3.14.1	Список нововведений
3.15	Java SE 12
3.15.1	Изменения
3.16	Java SE 13
3.16.1	Изменения
3.17	Java SE 14
3.17.1	Изменения
3.18	Java SE 15
3.18.1	Изменения
3.19	Java SE 16
3.19.1	Изменения
3.20	Java SE 17
3.20.1	Изменения
3.21	Java SE 18
3.21.1	Изменения
3.22	Java SE 19
3.22.1	Изменения
3.23	Java SE 20
3.23.1	Изменения
3.24	Java SE 21
3.24.1	Изменения
4	Классификация платформ Java
5	Java и Microsoft
6	Java и Android
7	Применения платформы Java
7.1	Производительность
8	Основные возможности
9	Основные идеи
9.1	Примитивные типы
9.1.1	Преобразования при математических операциях
9.2	Объектные переменные, объекты, ссылки и указатели
9.2.1	Дублирование ссылок и клонирование
9.2.2	Инициализация переменных
9.2.3	Сборка мусора
9.3	Классы и функции
9.3.1	Конструкторы
9.3.2	Статические методы и поля
9.3.3	Завершённость (final)
9.3.4	Абстрактность
9.3.5	Интерфейсы
9.3.5.1	Маркерные интерфейсы
9.3.6	Шаблоны в Java (generics)
9.3.7	Проверка принадлежности к классу
9.4	Обработка ошибок
9.5	Пространство имён
10	Примеры программ
11	Средства разработки ПО
12	См. также
13	Примечания
13.1	Комментарии
13.2	Документация
13.3	Источники
14	Литература
15	Ссылки
История создания

Джеймс Гослинг
Изначально язык назывался Oak («Дуб»), разрабатывался Джеймсом Гослингом для программирования бытовых электронных устройств. Из-за того, что язык с таким названием уже существовал, Oak был переименован в Java[6]. Назван в честь марки кофе Java, которая, в свою очередь, получила наименование одноимённого острова (Ява), поэтому на официальной эмблеме языка изображена чашка с горячим кофе. Существует и другая версия происхождения названия языка, связанная с аллюзией на кофемашину как пример бытового устройства, для программирования которого изначально язык создавался. В соответствии с этимологией в русскоязычной литературе с конца двадцатого и до первых лет двадцать первого века название языка нередко переводилось как Ява, а не транскрибировалось.

В результате работы проекта мир увидел принципиально новое устройство, карманный персональный компьютер Star7[7], который опередил своё время более чем на 10 лет, но из-за большой стоимости в 50 долларов не смог произвести переворот в мире технологии и был забыт.

Устройство Star7 не пользовалось популярностью, в отличие от языка программирования Java и его окружения. Следующим этапом жизни языка стала разработка интерактивного телевидения. Однако в 1994 году стало очевидным, что интерактивное телевидение было ошибкой.

С середины 1990-х годов язык стал широко использоваться для написания клиентских приложений и серверного программного обеспечения. Тогда же определённое распространение получила технология Java-апплетов — графических Java-приложений, встраиваемых в веб-страницы; с развитием возможностей динамических веб-страниц в 2000-е годы технология стала применяться редко.

В веб-разработке применяется Spring Framework; для документирования используется утилита Javadoc.

Основные особенности языка
Программы на Java транслируются в байт-код Java, выполняемый виртуальной машиной Java (JVM) — программой, обрабатывающей байтовый код и передающей инструкции оборудованию как интерпретатор.


Дюк — талисман Java
Достоинством подобного способа выполнения программ является полная независимость байт-кода от операционной системы и оборудования, что позволяет выполнять Java-приложения на любом устройстве, для которого существует соответствующая виртуальная машина. Другой важной особенностью технологии Java является гибкая система безопасности, в рамках которой исполнение программы полностью контролируется виртуальной машиной. Любые операции, которые превышают установленные полномочия программы (например, попытка несанкционированного доступа к данным или соединения с другим компьютером), вызывают немедленное прерывание.

Часто к недостаткам концепции виртуальной машины относят снижение производительности. Ряд усовершенствований несколько увеличил скорость выполнения программ на Java:

применение технологии трансляции байт-кода в машинный код непосредственно во время работы программы (JIT-технология) с возможностью сохранения версий класса в машинном коде,
обширное использование платформенно-ориентированного кода (native-код) в стандартных библиотеках,
аппаратные средства, обеспечивающие ускоренную обработку байт-кода (например, технология Jazelle, поддерживаемая некоторыми процессорами архитектуры ARM).
По данным сайта shootout.alioth.debian.org, для семи разных задач время выполнения на Java составляет в среднем в полтора-два раза больше, чем для C/C++, но при этом в некоторых случаях Java быстрее, а в отдельных случаях в 7 раз медленнее[8]. С другой стороны, для большинства из них потребление памяти Java-машиной было в 10—30 раз больше, чем программой на C/C++. Также примечательно исследование, проведённое компанией Google, согласно которому отмечается существенно более низкая производительность и бо́льшее потребление памяти в тестовых примерах на Java в сравнении с аналогичными программами на C++[9][10][11].

Идеи, заложенные в концепцию и различные реализации среды виртуальной машины Java, вдохновили множество энтузиастов на расширение перечня языков, которые могли бы быть использованы для создания программ, исполняемых на виртуальной машине[12]. Эти идеи нашли также выражение в спецификации общеязыковой инфраструктуры CLI, заложенной в основу платформы .NET компанией Microsoft.

История версий
Основная статья: История версий Java

Этот раздел нужно проверить на соответствие критериям взвешенности изложения.
Возможно, содержание статьи нарушает принцип взвешенного изложения, представляя малозначимые мнения и факты так же, как и более важные, либо уделяет слишком много места описанию какого-то одного аспекта темы в ущерб другим, не менее существенным. Пожалуйста, улучшите её в соответствии с правилами написания статей. (17 января 2024)
JDK 1.0
Разработка Java началась в 1990 году, первая официальная версия — Java 1.0, — была выпущена только 21 января 1996 года.

JDK 1.1
Вторая версия была выпущена 19 февраля 1997 года[13].

Библиотека Accessibility.
Java 2D.
Поддержка технологии drag-and-drop.
Полная поддержка Unicode, включая поддержку ввода на японском, китайском и корейском языках.
Поддержка воспроизведения аудиофайлов нескольких популярных форматов.
Полная поддержка технологии CORBA.
JIT-компилятор, улучшенная производительность.
Усовершенствования инструментальных средств JDK, в том числе поддержка профилирования Java-программ.
J2SE 1.2
Дата выпуска — 8 декабря 1998 года[14]. Кодовое имя — Playground. В данном случае встречается путаница. Выпускались книги, например, Beginning Java 2 by Ivor Horton (Mar 1999), фактически по J2SE 1.2 (бывшее название — Java 2). Вместе с тем, по сей день такие книги публикуются, например: Х. М. Дейтел, П. Дж. Дейтел, С. И. Сантри. Технологии программирования на Java 2. Распределённые приложения (2011).

В то время, когда Java 2 была исторически заменена следующими релизами, подобные названия книг дезориентируют в понимании, о какой же версии Java они написаны на самом деле. Если J2SE 1.2 принято считать за Java 2, а авторы книг за Java 2 принимают JDK 7, что приводит к полной путанице.

J2SE 1.3
Дата выпуска — 8 мая 2000 года. Кодовое имя — Kestrel.

J2SE 1.4
Дата выпуска — 6 февраля 2002 года. Кодовое имя — Merlin.

J2SE 5.0
Спецификация Java 5.0 была выпущена 30 сентября 2004 года, кодовое имя — Tiger. C этой версии изменена официальная индексация, вместо Java 1.5 правильнее называть Java 5.0. Внутренняя же индексация Sun осталась прежней — 1.x. Малые изменения теперь включаются без изменения индексации, для этого используется слово «Update» или буква «u», например, Java Development Kit 5.0 Update 22. Предполагается, что в обновления могут входить как исправления ошибок, так и небольшие добавления в API, JVM.

В данной версии разработчики внесли в язык целый ряд принципиальных дополнений:

Перечислимые типы (англ. enum). Ранее отсутствовавшие в Java типы оформлены по аналогии с C++, но при этом имеют ряд дополнительных возможностей.
Перечислимый тип является полноценным классом Java, то есть может иметь конструктор, поля, методы, в том числе — скрытые и абстрактные.
Перечисление может реализовывать интерфейсы.
Для перечислений имеются встроенные методы, дающие возможность получения значений типа по имени, символьных значений, соответствующих именам, преобразования между номером и значением, проверки типа на то, что он является перечислимым.
Аннотации — возможность добавления в текст программы метаданных, непосредственно не влияющих на выполнение кода, но допускающих использование для получения различных сведений о коде и его исполнении. Одновременно выпущен инструментарий для использования аннотированного кода. Одно из применений аннотаций — упрощение создания тестовых модулей для Java-кода.
Средства обобщённого программирования (англ. generics) — механизм, аналогичный средствам языков Ada[15] и Eiffel (позже также появились и в C#, принципиально отличаются от шаблонов C++), дающий возможность создавать классы и методы с полями и параметрами произвольного объектного типа. С использованием данного механизма реализованы новые версии коллекций стандартной библиотеки Java.
Методы с неопределённым числом параметров.
Autoboxing/Unboxing — автоматическое преобразование между скалярными типами Java и соответствующими типами-обёртками (например, между int — Integer). Наличие такой возможности сокращает код, поскольку исключает необходимость выполнения явных преобразований типов в очевидных случаях.
Разрешён импорт статических полей и методов.
В язык введён цикл по коллекции объектов (итератор, англ. foreach).
Введено использование Javadoc-комментариев, которые используются для автоматического оформления документации по комментариям в исходном коде.
Java SE 6
Релиз версии состоялся 11 декабря 2006 года, кодовое имя — Mustang. Изменена официальная индексация — вместо ожидаемой 6.0 версия значится как 6. Малые изменения, как и в Java 5.0, вносятся в обычные обновления версии, например, Java Standard Edition Development Kit 6 Update 27. Внесены следующие изменения:

Коллекции — добавлены интерфейсы для организации:
двухсторонних очередей, в том числе — блокирующих себя во время ожидания элемента;
множеств и словарей, организовывающих поиск по ближайшему соответствию (Navigable Set/Navigable Map).
При этом организованы новые классы, реализующие перечисленные интерфейсы[16].

Добавлена поддержка японского императорского календаря (наряду с уже существующими григорианским и буддийским календарями).
Доступны классы-потоки для чтения и передачи сжатых данных, с возможностью передачи их по сети. Сняты ограничения на количество файлов в архиве (ранее — 64 Кб), длину названия файла (ранее — 256 символов) и количество одновременно открытых файлов (ранее — 2000 шт).
Организована система управления кэшем и добавлена поддержка параметра «no-cache» в HTTP-запросе.
JConsole, графический мониторинг JVM, стала официально поддерживаемой утилитой.
Java HTTP Server позволяет создать полноценный HTTP-сервер, с минимально необходимыми функциональными свойствами.
Повысилась скорость вычислений на 70 %, скорость операций ввода-вывода возросла в два раза[17].
Swing — улучшена работоспособность OpenGL и DirectX; обработка текста на LCD; добавлен GifWriter, для работы с файлами формата GIF.
Исправлено большое количество ошибок.
JavaFX
Дата выпуска — 8 октября 2013 года.

JavaFX 2.2 вошёл в состав Java SE 7 update 6[18]. С 11-й версии модуль поставляется отдельно от JDK[19].

Java ME Embedded
Дата выпуска — 10 октября 2013 года. Кодовое имя — Micro Edition.

Java SE 7
Релиз версии состоялся 28 июля 2011 года, кодовое имя — Dolphin[20]. В финальную версию Java Standard Edition 7 не были включены все ранее запланированные изменения. Согласно плану развития (план «Б»)[21], включение нововведений будет разбито на две части: Java Standard Edition 7 (без лямбда-исчисления, проекта Jigsaw, и части улучшений проекта Coin[22]) и Java Standard Edition 8 (всё остальное), намеченный на конец 2012 года.

В новой версии, получившей название Java Standard Edition 7 (Java Platform, Standard Edition 7), помимо исправления большого количества ошибок, было представлено несколько новшеств. Так, например, в качестве эталонной реализации Java Standard Edition 7 использован не проприетарный пакет JDK, а его открытая реализация OpenJDK, а сам релиз новой версии платформы готовился при тесном сотрудничестве инженеров Oracle с участниками мировой экосистемы Java, комитетом JCP (Java Community Process) и сообществом OpenJDK. Все поставляемые Oracle бинарные файлы эталонной реализации Java Standard Edition 7 собраны на основе кодовой базы OpenJDK, сама эталонная реализация полностью открыта под лицензией GPLv2 с исключениями GNU ClassPath, разрешающими динамическое связывание с проприетарными продуктами. К другим нововведениям относятся:

интеграция набора небольших языковых улучшений Java, развиваемых в рамках проекта Coin,
добавлена поддержка языков программирования с динамической типизацией, таких, как Ruby, Python и JavaScript,
поддержка загрузки классов по URL,
обновлённый XML-стек, включающий JAXP 1.4, JAXB 2.2a и JAX-WS 2.2 и другие[23].
За 5 дней до выхода релиза Java Standard Edition 7 было обнаружено несколько серьёзных ошибок в горячей оптимизации циклов, которая включена по умолчанию и приводит виртуальную машину Java к краху. Специалисты Oracle найденные ошибки за столь короткий срок исправить не могли, но пообещали, что они будут исправлены во втором обновлении (Java 7 Update 2) и частично в первом[24].

Список нововведений
Поддержка динамически-типизированных языков (InvokeDynamic) — расширение JVM (семантики байт-кода), языка Java[25] для поддержки динамически-типизированных языков.
Строгая проверка class-файлов — class-файлы версии 51 (Java Standard Edition 7) или более поздней версии должны быть проверены typechecking-верификатором; JVM не должна переключаться на старый верификатор.
Изменение синтаксиса языка Java (Project Coin) — частичные изменения в языке Java, предназначенные для упрощения общих задач программирования:
Использование класса String[док. 1] в блоке switch.
Закрытие используемых ресурсов в блоке try (try-with-resources) — работает при использовании интерфейса AutoClosable[док. 2].
Объединённая обработка исключений в блоке catch (multi-catch exceptions) — перечисление обрабатываемых исключений в catch (… | … | …).
Повторное выбрасывание исключений (rethrowing exceptions) — передача возникшего исключения «вверх» по стеку вызовов.
Подчёркивания в числовых литералах для лучшего восприятия больших чисел.
Изменение вывода типа в Java generic при создании объекта.
Использование двоичных чисел (binary literals) — префикс 0b укажет, что используется двоичное число.
Упрощение вызова методов varargs — уменьшение предупреждений при вызове метода с переменным числом входящих переменных.
Модификация загрузчика классов (class-loader) — избежание тупиковых ситуаций в неиерархической топологии загрузки классов.
Закрытие ресурсов, открытых URLClassLoader[док. 3].
Обновление коллекций (JSR 166).
Поддержка Unicode 6.0.
Отделение языка пользователя и языка пользовательского интерфейса — обновление обработки языков для отделения локали от языка пользовательского интерфейса.
Новые интерфейсы I/O для платформы Java (nio.2).
Использование JDBC 4.1 и Rowset 1.1.
… (не закончено)
Java SE 8
Релиз версии состоялся 19 марта 2014 года. Кодовое имя — Octopus.

Список нововведений
Полноценная поддержка лямбда-выражений.
Ключевое слово default в интерфейсах для поддержки функциональности по умолчанию.
Статические методы в интерфейсах.
Ссылки на методы и конструкторы[26][27].
Функциональные интерфейсы (предикаты, поставщики и т. д.)
Потоки (stream) для работы с коллекциями.
Новый API для работы с датами.
… (не закончено)
Java SE 9
В связи со сложностями в реализации модульной системы в рамках проекта Jigsaw, релиз версии, первоначально запланированный 22 сентября 2016 года, несколько раз откладывался: сначала дата была перенесена на 23 марта 2017 года, потом — на 27 июля 2017 года, а затем — на 21 сентября 2017 года[28][29][30].

Последняя дата стала официальной датой релиза версии[31].

Список нововведений
Интеграция Jigsaw, в рамках которого разработана модульная система для платформы Java 9 и применена к JDK 9[32].
Обновление Process API для улучшения взаимодействия с процессами операционной системы. Обновление мотивировано тем, что разработчикам зачастую приходилось писать платформозависимый код для таких задач[33].
Временно экспериментальный[34][35] новый HTTP-клиент с поддержкой HTTP/2 и веб-сокетов; предназначен заменить устаревший класс HttpURLConnection[док. 4][34].
Сжатые строки: если содержимое строки позволяет, она может кодироваться в Latin-1 (один байт на символ); выбор кодировки конкретного экземпляра класса String отображается в значении переменной-флага, которая теперь есть у всех строк.[36]
Поддержка указанных в NIST FIPS 202 алгоритмов хеширования SHA-3, кроме SHAKE128 и SHAKE256. Алгоритмы использования SHA-3 в качестве основы для других криптографических функций не реализованы в силу отсутствия соответствующих стандартов[37].
Улучшены средства для пометки устаревшего API. В аннотацию @Deprecated добавлен параметр, позволяющий указывать версию программы, с которой использование отмеченного элемента не рекомендуется, а также — параметр, позволяющий указать, что запланировано удаление элемента в какой-либо из будущих версий[38].
private методы в интерфейсах[39].
Поддержка GTK+ 3 на Linux[40].
Java SE 10
Дата релиза: 20 марта 2018 года[41].

Список нововведений
Официальный частичный список нововведений и план релиза расположен на сайте OpenJDK.

Вывод типов локальных переменных, помеченных с помощью ключевого слова var[42].
Создание прозрачного интерфейса сборщика мусора для упрощения разработки новых сборщиков[43].
Уменьшено время задержек многопоточного сборщика мусора G1 за счёт реализации параллельного полного цикла сборки мусора[44].
Возможность выполнять функции обратного вызова на потоках, не делая глобальных блокировок[45] в рамках всех потоков[46].
Поддержка символов из новых расширений Unicode: cu (тип валюты), fw (первый день недели), rg (двухбуквенные коды стран и регионов), tz (часовой пояс)[47].
HotSpot VM теперь может выделять память кучи для объектов на альтернативных устройствах оперативной памяти, в том числе тех, которые обладают энергонезависимой памятью, как, например, накопители Intel Optane Memory[48].
Новый экспериментальный JIT-компилятор Graal, предоставляющий возможности Ahead-of-Time компиляции; по умолчанию отключён, работает только на Linux/x64[49].
Обновление системы нумерации версий Java SE и JDK с целью приближения к схеме управления версиями по времени[50].
Java SE 11
Официальный частичный список нововведений и план релиза расположен на сайте OpenJDK. Дата релиза — 25 сентября 2018 года.

Список нововведений
Обновление системы управления доступом, позволяющее вложенным классам обращаться к закрытым (private) методам и полям внешнего класса (и наоборот) без необходимости создания компилятором промежуточных методов с повышением уровня доступа[51].
Epsilon — новый сборщик мусора, собственно сборкой мусора не занимающийся вообще; при использовании Epsilon превышение предела выделяемой памяти приводит к завершению работы JVM[52].
Стандартизирован клиент HTTP с поддержкой HTTP/2, введённый в Java 9 как экспериментальный[53].
Параметры лямбда-функций могут быть неявно типизированы путём вывода типов через ключевое слово (var) для унификации с синтаксисом локальных переменных, введённым в JDK 10[54].
Поддержка 10-й версии стандарта Unicode[55].
Поддержка протокола TLS 1.3[56].
Экспериментальный масштабируемый сборщик мусора ZGC с низкими задержками. По умолчанию отключён, работает только на Linux/x64[57].
Java SE 12
Дата релиза — 13 марта 2019 года.

Изменения
блок switch может использоваться в выражениях присваивания значения переменной;
добавлена поддержка 11-й версии стандарта Unicode;
сборщик мусора ZGC: добавлена поддержка выгрузки классов;
сборщик мусора G1: добавлена экспериментальная возможность размещения старого поколения кучи на альтернативных модулях памяти, например, NVDIMM[англ.];
в классе NumberFormat добавлена поддержка компактного вывода больших чисел, например: 1K=1000, 1M=1 000 000;
устранены некоторые неиспользумые (или признанные устаревшими (deprecated) классы и/или их методы, например, класс SecurityWarning из пакета AWT, методы finalize в классах FileInputStream и FileOutputStream[58].
Java SE 13
Дата релиза — 17 сентября 2019 года[59].

Изменения
в блоках switch добавлена возможность использования ключевого слова yield, возвращающего указанное за ним значение;
для компактной записи строковых констант введена экспериментальная возможность работы с текстовыми блоками, обрамлённых тройками двойных кавычек (""");
в классе FileSystems пакета java.nio.file добавлены новые реализации метода newFileSystem;
методы get/put класса ByteBuffer пакета java.nio пересылают данные вне зависимости от текущей позиции в буфере передачи;
добавлена поддержка Unicode 12.1;
сборщик мусора ZGC возвращает более неиспользуемую память кучи ОС, при этом максимальный поддерживаемый размер памяти кучи увеличен до 16 ТБ;
в JCA добавлена возможность чтения приватных ключей в формате CryptoAPI: Next Generation (англ. Microsoft CryptoAPI);
для macOS исключена поддержка стиля оформления (look-and-feel) Swing Motif[60].
Java SE 14
Дата релиза — 17 марта 2020 года[59].

Изменения
экспериментально введено ключевое слово record — для обозначения неизменяемых (final) классов, являющихся контейнерами неизменяемых данных (записей);
введено сопоставление шаблонов для оператора instanceof в блоках switch;
в метках case блоков switch могут использоваться «стрелочные» (->) операторы;
исключён сборщик мусора Concurrent Mark and Sweep (CMS);
методы suspend и resume классов Thread и ThreadGroup признаны устаревшими (deprecated)[61].
Java SE 15
Дата релиза — 15 сентября 2020 года[59].

Изменения
добавлена экспериментальная возможность использования запечатанных (sealed) классов/интерфейсов, при объявлении которых с помощью нового ключевого слова permits можно указывать, какие классы/интерфейсы могут наследовать данный запечатанный класс/интерфейс;
добавлена возможность использования скрытых (hidden) классов, которые не могут использоваться непосредственно байт-кодом Java или другими классами;
в синтаксис языка официально введена экспериментально добавленная в Java 13 возможность работы с текстовыми блоками;
добавлена поддержка Unicode 13.0;
в классе CharSequence добавлен default-метод isEmpty;
в классе TreeMap добавлена возможность перегрузки методов putIfAbsent, computeIfAbsent, computeIfPresent, compute, merge[62].
Java SE 16
Дата релиза — 16 марта 2021 года[59].

Изменения
в синтаксис языка официально введены экспериментально добавленные в Java 14 возможности работы с записями (record) и использования instanceof в блоках switch;
добавлен Foreign Linker API, предназначенный для замены механизма JNI;
добавлен Foreign-Memory Access API, позволяющий Java-приложениям эффективно и безопасно использовать память вне кучи Java;
добавлено динамическое освобождение Metaspace — области памяти, в которой хранится статическая информация Java-приложения (метаданные загруженных классов), и возвращение освобождённой памяти ОС;
в JCA добавлена поддержка алгоритма SHA-3;
в классах SocketChannel и ServerSocketChannel пакета java.nio.channels добавлена поддержка использования сокетов домена Unix;
добавлено свойство jdk.tls.maxHandshakeMessageSize, позволяющее задать максимальный размер сообщения рукопожатия для протоколов TLS/DTLS;
в интерфейс Stream добавлен метод toList, позволяющий преобразовывать поток в список;
добавлен Vector API, предназначенный для использования возможностей векторного исчисления;
методы stop, destroy, isDestroyed, setDaemon, isDaemon класса ThreadGroup признаны устаревшими (deprecated);
сборщик мусора ZGC может производить одновременную обработку стеков разных потоков;
сборщик мусора G1 может одновременно освобождать память, занимавшуюся разными потоками[63].
Java SE 17
Дата релиза — 14 сентября 2021 года[59].

Изменения
в синтаксис языка официально введена экспериментально добавленная в Java 15 возможность работы с запечатанными (sealed) классами/интерфейсами;
экспериментально расширена возможность использования блоков switch — в них можно выполнять разные действия в зависимости от того, к какому классу относится указанный объект, т.е. метки case могут быть именами классов;
в генераторах псевдослучайных чисел (пакет java.util) добавлены новые алгоритмы/методы генерации;
добавлен Foreign Function & Memory API, позволяющий Java-приложениям взаимодействовать с кодом и данными вне среды выполнения Java;
в классе Console пакета java.io добавлен метод charset, возвращающий используемый консолью набор символов;
добавлено новое системное свойство native.encoding, позволяющее узнать обозначение (наименование) кодировки символов базовой среды хоста;
в пакет java.time добавлен интерфейс InstantSource, позволяющий получать информацию о текущем моменте времени;
в пакет java.util добавлен класс HexFormat, позволяющий преобразовывать числа шестнадцатеричной системы счисления в числа других систем счисления (или строки) и обратно;
в MacOS
добавлена возможность использования нового конвейера рендеринга 2D-графики Swing — Apple Metal;
интерфейс UserDefinedFileAttributeView пакета java.nio.file.attribute расширен для возможнсти получения доступа к дополнительным атрибутам файлов;
в классе FileSystemView пакета javax.swing.filechooser добавлен метод getSystemIcon, позволяющий загружать иконки высокого качества/разрешения;
в классе DatagramSocket пакета java.net добавлены методы joinGroup и leaveGroup, предназначенные соответственно для присоединения к группе многоадресной рассылки или выхода из нее;
исключён механизм активации RMI;
в виртуальной машине Java HotSpot исключён код AOT-компилятора[64].
Java SE 18
Дата релиза — 22 марта 2022 года[59].

Изменения
во всех Java SE API кодировка по умолчанию изменена на UTF-8;
добавлена утилита простого веб-сервера jwebserver, запускаемая из командной строки;
улучшена безопасность при использовании методов рефлексии;
добавлен интерфейс поставщика услуг для имени хоста и разбора сетевого адреса;
интерфейс JavaFileManager пакета javax.tools расширен 2 новыми методами — getJavaFileForOutputForOriginatingFiles и getFileForOutputForOriginatingFiles, которые используются для создания новых файлов на основании указанных исходных файлов; интерфейс Filer пакета javax.annotation.processing использует эти методы при создании новых файлов в той же манере;
в класс Charset пакета java.nio.charset добавлена перегрузка метода forName, вторым аргументом которого может указываться наименование резервной кодировки, на случай отсутствия в системе (или невозможности определения) запрашиваемой первым аргументом;
признаны устаревшими (deprecated)
механизмы финализации (методы finalize) разных классов;
метод stop класса Thread;
в сборщике мусора G1 максимальный размер обрабатываемых регионов кучи увеличен с 32 до 512 Мб;
в сборщиках мусора SerialGC, ParallelGC, ZGC добавлена поддержка дедупликации[65].
Java SE 19
Дата релиза — 20 сентября 2022 года[59].

Изменения
добавлены экспериментальные возможности
работы с виртуальными потоками;
проверки, является ли передаваемый методу объект записью (record);
добавлена поддержка Unicode 14.0;
в потоках вывода System.out и System.err добавлены новые свойства — stdout.encoding и stderr.encoding соответственно, которые определяют кодировку символов потока;
добавлена поддержка токенов привязки каналов TLS при аутентификации по протоколам Kerberos/Negotiate через HTTPS;
в классах DateTimeFormatter и DateTimeFormatterBuilder пакета java.time.format добавлены новые возможности определения форматов времени и дат;
в классах HashMap, LinkedHashMap, WeakHashMap, HashSet, LinkedHashSet добавлены статические методы, позволяющие создавать новые хэш-таблицы;
в классе SSLParameters пакета javax.net.ssl добавлены методы getSignatureSchemes и setSignatureSchemes, позволяющие соответственно получать и задавать схемы проверки электронных цифровых подписей при соединениях по протоколам TLS/DTLS;
изменено действие методов класса ThreadGroup:
методы destroy и setDaemon не делают ничего;
метод isDestroyed всегда возвращает false;
методы suspend, resume и stop всегда выбрасывают исключение UnsupportedOperationException;
конструкторы класса Locale пакета java.util признаны устаревшими (deprecated) — вместо них рекомендуется использовать статический метод of[66].
Java SE 20
Дата релиза — 21 марта 2023 года[59].

Изменения
при работах с потоками введена экспериментальная возможность использования ограниченных значений (параметризованный класс ScopedValue), которые могут эффективно и безопасно использоваться разными потоками;
добавлена поддержка Unicode 15.0;
в классе SSLParameters пакета javax.net.ssl добавлены методы getNamedGroups и setNamedGroups, позволяющие в приоритетном порядке настраивать списки групп алгоритмов обмена ключами при соединениях по протоколам TLS/DTLS;
изменено действие методов suspend, resume и stop класса Thread — они всегда выбрасывают исключение UnsupportedOperationException;
признаны устаревшими (deprecated)
конструкторы класса URL пакета java.net — вместо них рекомендуется использовать новый статический метод of этого класса или методы toURL класса URI из того же пакета;
используемые в Java-апплетах классы MLet, MLetContent, PrivateMLet, MLetMBean пакета javax.management.loading;
в сборщике мусора G1 улучшена параллельная обработка потоков[67].
Java SE 21
Дата релиза — 19 сентября 2023 года[59].

Изменения
в синтаксис языка официально введены ранее экспериментально добавленные возможности
расширения использования блоков switch — в них можно выполнять разные действия в зависимости от того, к какому классу относится указанный объект, т.е. метки case могут быть именами классов (с Java 17);
проверки, является ли передаваемый методу объект записью (record) (с Java 19);
работы с виртуальными потоками (с Java 19);
добавлены параметризованные интерфейсы SequencedCollection, SequencedSet, SequencedMap для работы с коллекциями, в которых чётко определён порядок следования элементов;
добавлен Key Encapsulation Mechanism API — механизм обеспечения надёжной работы с симметричными криптосистемами;
добавлены экспериментальные возможности работы
со строковыми шаблонами, в которых могут использоваться текстовые блоки;
безымянными шаблонами и переменными, обозначемыми символом «_»;
с безымянными классами — внутри java-файла можно без определения имени класса записать определение метода main;
класс HttpClient пакета java.net.http теперь реализует интерфейс AutoCloseable;
в классы Pattern пакета java.util.regex и String добавлены методы splitWithDelimiters, возвращающие строковые массивы, состоящие как из обычных символов, так и символов-разделителей;
в классах StringBuilder и StringBuffer добавлены методы repeat, возвращающие повторённые указанное число раз последовательности символов;
в классе Character добавлены новые методы работы с символами эмодзи;
в классе ThreadGroup удалён метод allowThreadSuspension;
удалён класс Compiler;
в сборщике мусора ZGC добавлена раздельная обработка объектов молодого и старого поколений[68].
Классификация платформ Java
Внутри Java существует несколько основных семейств технологий:

Java SE — Java Standard Edition — основное издание Java. Содержит компиляторы, API, Java Runtime Environment; подходит для создания пользовательских приложений, в первую очередь — для настольных систем.
Jakarta EE (ранее — Java EE (Enterprise Edition)) представляет собой набор спецификаций для создания ПО уровня предприятия. В 2017-м проект Java EE был передан Eclipse Foundation, и тогда же его наименование изменилось на текущее[69][70]. Модули Java EE удалены из Java SE с 11-й версии[71].
Java ME — Java Micro Edition, создана для использования в устройствах, ограниченных по вычислительной мощности, например, в мобильных телефонах, КПК, встроенных системах;
Java Card — технология предоставляет безопасную среду для приложений, работающих на смарт-картах и других устройствах с очень ограниченным объёмом памяти и возможностями обработки.
Java и Microsoft
Компанией Microsoft была разработана собственная реализация JVM под названием Microsoft Java Virtual Machine[англ.] (MSJVM)[72], включавшаяся в состав различных операционных систем, начиная с Windows 98 (также входила в Internet Explorer от версии 3 и выше, что позволяло использовать MSJVM в ОС Windows 95 и Windows NT 4 после установки IE3+ на данные ОС).

MSJVM имела существенные отличия от Sun Java, во многом ломающие основополагающую концепцию переносимости программ между разными платформами:

отсутствие поддержки программного интерфейса вызова удалённых методов (RMI);
отсутствие поддержки технологии JNI;
наличие нестандартных расширений, таких, как средства интеграции Java и DCOM, работающих только на платформе Windows.
Тесная интеграция Java с DCOM и Win32 поставила под вопрос кроссплатформенную парадигму языка. Впоследствии это явилось поводом для судебных исков со стороны Sun Microsystems к Microsoft. Суд принял сторону компании Sun Microsystems. В конечном счёте между двумя компаниями была достигнута договорённость о возможности продления срока официальной поддержки пользователей нестандартной Microsoft JVM до конца 2007 года[72].

В 2005 году компанией Microsoft для платформы .NET был представлен Java-подобный язык J#, не соответствующий официальной спецификации языка Java и исключённый впоследствии из стандартного инструментария разработчика Microsoft Visual Studio, начиная с Visual Studio 2008[73].

Java и Android
Основная статья: Android
Язык Java активно используется для создания мобильных приложений под операционную систему Android. При этом программы компилируются в нестандартный байт-код для использования их виртуальной машиной Dalvik (начиная с Android 5.0 Lollipop виртуальная машина заменена на ART). Для такой компиляции используется дополнительный инструмент, а именно Android SDK (Software Development Kit), разработанный компанией Google.

Разработку приложений можно вести в среде Android Studio, NetBeans, в среде Eclipse,

Применения платформы Java
Следующие успешные проекты реализованы с привлечением Java (J2EE) технологий: RuneScape, Amazon[74][75], eBay[76][77], LinkedIn[78], Yahoo![79].

Следующие компании в основном фокусируются на Java- (J2EE-) технологиях: SAP, IBM, Oracle. В частности, СУБД Oracle Database включает JVM как свою составную часть, обеспечивающую возможность непосредственного программирования СУБД на языке Java, включая, например, хранимые процедуры[80].

Производительность
Программы, написанные на Java, имеют репутацию более медленных и занимающих больше оперативной памяти, чем написанные на языке C[8]. Тем не менее, скорость выполнения программ, написанных на языке Java, была существенно улучшена с выпуском в 1997—1998 годах так называемого JIT-компилятора в версии 1.1 в дополнение к другим особенностям языка для поддержки лучшего анализа кода (такие, как внутренние классы, класс StringBuffer[док. 5], упрощённые логические вычисления и так далее). Кроме того, была произведена оптимизация виртуальной машины Java — с 2000 года для этого используется виртуальная машина HotSpot. По состоянию на февраль 2012 года код Java 7 приблизительно в 1,8 раза медленнее кода, написанного на языке Си[81].

Некоторые платформы предлагают аппаратную поддержку выполнения для Java[82]. К примеру, микроконтроллеры, выполняющие код Java на аппаратном обеспечении вместо программной JVM, а также основанные на ARM процессоры, которые поддерживают выполнение байт-кода Java через опцию Jazelle.

Основные возможности
Автоматическое управление памятью;
Расширенные возможности обработки исключительных ситуаций;
Богатый набор средств фильтрации ввода-вывода;
Набор стандартных коллекций: массив, список, стек и т.п;
Наличие простых средств создания сетевых приложений (в том числе — с использованием протокола RMI);
Наличие классов, позволяющих выполнять HTTP-запросы и обрабатывать ответы;
Встроенные в язык средства создания многопоточных приложений, которые потом были портированы на многие языки, например, Python;
Унифицированный доступ к базам данных:
на уровне отдельных SQL-запросов — на основе JDBC, SQLJ;
на уровне концепции объектов, обладающих способностью к хранению в базе данных — на основе Java Data Objects[англ.] и Java Persistence API;
Поддержка обобщений (с версии 1.5);
Поддержка лямбд, замыканий, возможностей функционального программирования (с Java 8).
Основные идеи
Примитивные типы
В языке Java только 8 примитивных (скалярных, простых) типов: boolean, byte, char, short, int, long, float, double. Существует также вспомогательный девятый примитивный тип — void, однако переменные и поля такого типа не могут быть объявлены в коде, а сам тип используется только для описания соответствующего ему класса, для использования при рефлексии: например, с помощью класса Void[док. 6] можно узнать, является ли определённый метод типа void: Hello.class.getMethod("main", String[].class).getReturnType() == Void.TYPE.

Длины и диапазоны значений примитивных типов определяются стандартом, а не реализацией, и приведены в таблице. Тип char сделали двухбайтовым для удобства локализации (один из идеологических принципов Java): когда складывался стандарт, уже существовал Unicode-16, но не Unicode-32. Поскольку в результате не осталось однобайтового типа, добавили новый тип byte, причём в Java, в отличие от других языков, он не является беззнаковым. Типы float и double могут иметь специальные значения
+
∞{\displaystyle +\infty },
−
∞{\displaystyle -\infty } и «не число» (NaN). Для типа double они обозначаются Double.POSITIVE_INFINITY, Double.NEGATIVE_INFINITY, Double.NaN; для типа float — так же, но с приставкой Float вместо Double. Минимальные и максимальные значения, принимаемые типами float и double, тоже стандартизованы.

Тип	Длина (в байтах)	Диапазон или набор значений
boolean	1 в массивах, 4 в переменных[83]	true, false
byte	1	−128..127
char	2	0..216−1, или 0..65535
short	2	−215..215−1, или −32768..32767
int	4	−231..231−1, или −2147483648..2147483647
long	8	−263..263−1, или примерно −9.2·1018..9.2·1018
float	4	-(2-2−23)·2127..(2-2−23)·2127, или примерно −3.4·1038..3.4·1038, а также
−
∞{\displaystyle -\infty },
∞{\displaystyle \infty }, NaN
double	8	-(2-2−52)·21023..(2-2−52)·21023, или примерно −1.8·10308..1.8·10308, а также
−
∞{\displaystyle -\infty },
∞{\displaystyle \infty }, NaN
Такая жёсткая стандартизация была необходима, чтобы сделать язык платформенно-независимым, что является одним из идеологических требований к Java. Тем не менее, одна небольшая проблема с платформенной независимостью всё же осталась. Некоторые процессоры используют для промежуточного хранения результатов 10-байтовые регистры или другими способами улучшают точность вычислений. Для того, чтобы сделать Java максимально совместимой между разными системами, в ранних версиях любые способы повышения точности вычислений были запрещены. Однако это приводило к снижению быстродействия. Выяснилось, что ухудшение точности ради платформенной независимости мало кому нужно, тем более если за это приходится платить замедлением работы программ. После многочисленных протестов этот запрет отменили, но добавили ключевое слово strictfp, запрещающее повышение точности. Начиная с Java 17, запрет на повышение точности снова начал действовать, а ключевое слово strictfp было объявлено устаревшим[84].

Преобразования при математических операциях
В языке Java действуют следующие правила:

Если один операнд имеет тип double, другой тоже преобразуется к типу double.
Иначе, если один операнд имеет тип float, другой тоже преобразуется к типу float.
Иначе, если один операнд имеет тип long, другой тоже преобразуется к типу long.
Иначе оба операнда преобразуются к типу int.
Данный способ неявного преобразования встроенных типов полностью совпадает с преобразованием типов в Си/C++[85].

Объектные переменные, объекты, ссылки и указатели
В языке Java имеются только динамически создаваемые объекты. Переменные объектного типа и объекты в Java — совершенно разные сущности. Переменные объектного типа являются ссылками, то есть аналогами указателей на динамически создаваемые объекты. Это подчёркивается синтаксисом описания переменных. Так, код на C++ может выглядеть следующим образом:

double a[10][20];
Foo b(30);
Но то же самое на Java будет выглядеть совсем по-другому:

double[][] a = new double[10][20];
Foo b = new Foo(30);
При присваиваниях, передаче в подпрограммы и сравнениях объектные переменные ведут себя как указатели, то есть присваиваются, копируются и сравниваются адреса объектов. А при доступе с помощью объектной переменной к полям данных или методам объекта не требуется никаких специальных операций разыменовывания — этот доступ осуществляется так, как если бы объектная переменная была самим объектом.

Объектными являются переменные любого типа, кроме примитивного. Явных указателей в Java нет. В отличие от указателей C, C++ и других языков программирования, ссылки в Java в высокой степени безопасны благодаря жёстким ограничениям на их использование.

Нельзя преобразовывать объект типа int или любого другого примитивного типа в указатель или ссылку и наоборот.
Над ссылками запрещено выполнять операции ++, −−, +, − или любые другие арифметические и логические операции (&&, ||, ^^).
Преобразование типов между ссылками жёстко регламентировано. За исключением ссылок на массивы, разрешено преобразовывать ссылки только между наследуемым типом и его наследником, причём преобразование наследуемого типа в наследующий должно быть явно задано, а во время выполнения производится проверка его осмысленности. Преобразования ссылок на массивы разрешены лишь тогда, когда разрешены преобразования их базовых типов, а также нет конфликтов размерности.
В Java нет операций взятия адреса (&) или взятия объекта по адресу (*). Амперсанд (&) означает всего лишь «побитовое и» (двойной амперсанд — «логическое и»). Однако для булевых типов одиночный амперсанд означает «логическое и», отличающееся от двойного тем, что цепь проверок не прекращается при получении в выражении значения false[86]. Например, a == b && foo() == bar() не повлечёт вызовов foo() и bar() в случае, если a != b, тогда как использование & — повлечёт в любом случае.
Благодаря таким специально введённым ограничениям в Java невозможно прямое манипулирование памятью на уровне физических адресов (хотя определено значение ссылки, не указывающей ни на что: null).

Если нужен указатель на примитивный тип, используются классы-обёртки примитивных типов: Boolean, Byte, Character, Short, Integer, Long, Float, Double.

Дублирование ссылок и клонирование
При присваивании не происходит копирования объекта, так как объектные переменные — ссылочные. Так, если написать

Foo foo, bar;
. . .
bar = foo;
то произойдёт копирование адреса из переменной foo в переменную bar. То есть foo и bar будут указывать на одну и ту же область памяти, то есть на один и тот же объект; попытка изменить поля объекта, на который ссылается переменная foo, будет менять объект, с которым связана переменная bar, и наоборот. Если же необходимо получить именно ещё одну копию исходного объекта, пользуются или методом (функцией-членом, в терминологии C++) clone(), создающим копию объекта, или (реже) копирующим конструктором (конструкторы в Java не могут быть виртуальными, поэтому экземпляр класса-потомка будет неправильно скопирован конструктором класса-предка; метод клонирования вызывает нужный конструктор и тем самым позволяет обойти это ограничение).

Метод clone()[док. 7] требует, чтобы класс реализовывал интерфейс Cloneable[док. 8]. Если класс реализует интерфейс Cloneable, по умолчанию clone() копирует все поля (мелкая копия). Если требуется не копировать, а клонировать поля (а также их поля и так далее), надо переопределять метод clone(). Определение и использование метода clone() часто является нетривиальной задачей[87].

Инициализация переменных
Все переменные или требуют явного определения, или автоматически заполняются нулями (0, null, false). Таким образом, исчезают гейзенбаги, связанные со случайным использованием неинициализированной памяти, характерные для низкоуровневых языков вроде Си.

Сборка мусора
В языке Java невозможно явное удаление объекта из памяти — вместо этого реализована сборка мусора. Традиционным приёмом, дающим сборщику мусора «намёк» на необходимость освобождения памяти, является присваивание переменной пустого значения null, что может оказаться эффективным при необходимости освободить более не требующийся объект, ссылка на который хранится в долгоживущем объекте[88]. Это, однако, не значит, что объект, заменённый значением null, будет непременно и немедленно удалён, но есть гарантия, что этот объект будет удалён именно в будущем. Данный приём всего лишь устраняет ссылку на объект, то есть отвязывает указатель от объекта в памяти. При этом следует учитывать, что объект не будет удалён сборщиком мусора, пока на него указывает хотя бы одна ссылка из используемых переменных или объектов. Существуют также методы для инициации принудительной сборки мусора, но не гарантируется, что они будут вызваны исполняющей средой, и их не рекомендуется использовать для обычной работы.

Классы и функции
Java не является процедурным языком: любая функция может существовать только внутри класса. Это подчёркивает терминология языка Java, где нет понятий «функция» или «функция-член» (англ. member function), а только метод. В методы превратились и стандартные функции. Например, в Java нет функции sin(), а есть метод Math.sin() класса Math (содержащего, кроме sin(), методы cos(), exp(), sqrt(), abs() и многие другие).

Как и в языке C, любая исполняемая программа на Java должна иметь точку входа, которой является функция с именем main — она должна быть единственной в программе и, в отличие от Си, всегда статической. При этом, начиная с Java 21, в которой были введены безымянные классы, допускается определять метод main (точку входа), не определяя имени главного класса.

Конструкторы в Java не считаются методами. Деструкторов в Java не существует, а метод finalize() ни в коем случае нельзя считать аналогом деструктора.

Конструкторы
Конструктор — это специальный метод, который обязательно вызывается при создании нового объекта, то есть объект (экземпляр класса) не может быть создан без вызова конструктора класса. Не всегда удобно инициализировать все переменные класса при создании его экземпляра, поэтому переменные экземпляра часто объявляют внутри тела конструктора, а инициализируют как аргументы конструктора при создании экземпляра класса. Иногда проще, чтобы какие-то значения были бы созданы по умолчанию при создании объекта. В таком случае переменные объявляются и инициализируются внутри тела конструктора.

Конструктор инициализирует объект непосредственно во время создания. Имя конструктора совпадает с именем класса, включая регистр, а по синтаксису конструктор похож на метод без возвращаемого значения.

private int Cat();  // так выглядит метод по имени Cat
Cat();              // так выглядит конструктор класса Cat
В отличие от метода, конструктор никогда ничего не возвращает.

Конструктор определяет действия, выполняемые при создании объекта класса, и является важной частью класса. Как правило, программисты стараются явно указать конструктор. Если явного конструктора нет, то Java автоматически создаст его (пустым) для использования по умолчанию.

В качестве примера можно рассмотреть некий класс Box, представляющий собой описание коробки. Конструктор класса просто установит начальные размеры для коробки.

class Box {
    int width; // ширина коробки
    int height; // высота коробки
    int depth; // глубина коробки

    // Конструктор
    Box(int a, int b) {
        width = a;
        height = b;
        depth = 10;
    }

    // вычисляем объём коробки
    int getVolume() {
    	return width * height * depth;
    }
}
Статические методы и поля
В Java (как и в C++) используются статические поля и статические методы (англ. static method — в теории программирования их также называют методами класса), которые задаются при помощи ключевого слова static. Статические поля (переменные класса) имеют тот же смысл, что и в C++: каждое такое поле является собственностью класса, поэтому для доступа к статическим полям не требуется создавать экземпляры соответствующего класса.

Например, математические функции, реализованные в классе Math[док. 9], представляют собой как раз статические методы данного класса. Поэтому их можно вызывать напрямую из класса, не создавая его экземпляра, например:

double x = Math.sin(1);
Создание экземпляра статического класса запрещают с помощью приватного конструктора. Например, создание экземпляра класса Math приведёт к ошибке на этапе компиляции:

Math m = new Math(); // Error: Math() has private access in java.lang.Math
double x = m.sin(1); // Метода sin у объекта не существовало бы, т. к. он статичный
Поскольку статические методы существуют независимо от объектов (экземпляров класса), они не имеют доступа к обычным (не статическим) полям и методам данного класса. В частности, при реализации статического метода недопустимо использовать идентификатор this.

Возможность статического импорта позволяет вызывать статические функции и константы без указания класса. Пример без статического импорта:

double x = Math.sin(Math.tan(Math.sqrt(y)) + Math.floor(24.5)) + Math.cos(42 * Math.PI);
Тот же пример, но со статическим импортом:

import static java.lang.Math.*;
...
double x = sin(tan(sqrt(y)) + floor(24.5)) + cos(42 * PI);
Завершённость (final)
Ключевое слово final (финальный) имеет разные значения при описании поля, метода или класса.

Финальное поле класса инициализируется при описании или в конструкторе класса (а статическое поле — в статическом блоке инициализации). Впоследствии его значение не может быть изменено. Если статическое поле класса или переменная проинициализированы константным выражением, они рассматриваются компилятором как именованная константа; в таком случае их значение может быть использовано в операторах switch (для констант типов int и String, в том числе — элементов перечислений), а также для условной компиляции (для констант типа boolean) при использовании с оператором if.
Значения локальных переменных, а также параметров метода, помеченных ключевым словом final, не могут быть изменены после присвоения. При этом их значения могут использоваться внутри анонимных классов.
Метод класса, отмеченный словом final, не может быть переопределён при наследовании.
Финальный класс не может иметь наследников.
Абстрактность
В Java методы, не объявленные явно как static, final или private, являются виртуальными в терминологии C++: при вызове метода, по-разному определённого в базовом и наследующем классах, всегда производится проверка времени выполнения.

Абстрактным методом (модификатор abstract) в Java называется метод, для которого заданы параметры и тип возвращаемого значения, но не задано тело. Абстрактный метод определяется в классах-наследниках. Аналог абстрактного метода в C++ — чисто виртуальная функция (pure virtual function). Для того чтобы в классе можно было описывать абстрактные методы, сам класс тоже должен быть описан как абстрактный. Объекты абстрактного класса создавать нельзя.

Интерфейсы
Высшей степенью абстрактности в Java является интерфейс (модификатор interface). Интерфейс содержит преимущественно абстрактные методы, имеющие всеобщий уровень доступа: описатели abstract и public для них даже не требуются. Однако с версий Java 8 и 9 были введены возможности использования в интерфейсах

- Java 8: статических (static) методов и методов по умолчанию (default);

- Java 9: методов, имеющих уровень доступа private.

Эти методы содержат тело, а значит абстрактными не являются, но в конкретной реализации интерфейса default-методы могут быть переопределены.

Интерфейс в Java не считается классом, хотя, по сути, является полностью абстрактным классом. Класс может наследовать/расширять (extends) другой класс или реализовывать (implements) интерфейс. Кроме того, интерфейс может наследовать/расширять (extends) другой интерфейс.

В Java класс не может наследовать более одного класса, зато может реализовывать несколько интерфейсов. Множественное наследование интерфейсов не запрещено, то есть один интерфейс может наследоваться от нескольких.

Интерфейсы можно использовать в качестве типов параметров методов. Нельзя создавать экземпляры интерфейсов.

Маркерные интерфейсы
В Java есть интерфейсы, которые не содержат методов для реализации, а специальным образом обрабатываются JVM: Cloneable, Serializable, RandomAccess, Remote.

Шаблоны в Java (generics)
Начиная с версии Java 5.0 в языке появился механизм обобщённого программирования — шаблоны, внешне близкие к шаблонам C++. С помощью специального синтаксиса в описании классов и методов можно указать параметры-типы, которые внутри описания могут использоваться в качестве типов полей, параметров и возвращаемых значений методов.

// Объявление обобщённого класса
class GenericClass<E> {
  E getFirst() { ... }
  void add(E obj) { ... }
}

// Использование обобщённого класса в коде
GenericClass<String> obj = new GenericClass<>();
obj.add("qwerty");
String p = obj.getFirst();
Допускается обобщённое объявление классов, интерфейсов и методов. Кроме того, синтаксис поддерживает ограниченные объявления типов-параметров: указание в объявлении конструкции вида <T extends A & B & C...> требует, чтобы тип-параметр T реализовывал интерфейсы A, B, C и так далее.

В отличие от шаблонов C#, шаблоны Java не поддерживаются средой исполнения — компилятор просто создаёт байт-код, в котором никаких шаблонов уже нет. Реализация шаблонов в Java принципиально отличается от реализации аналогичных механизмов в C++: компилятор не порождает для каждого случая использования шаблона отдельный вариант класса или метода-шаблона, а просто создаёт одну реализацию байт-кода, содержащую необходимые проверки и преобразования типов. Это приводит к ряду ограничений использования шаблонов в программах на Java.

Проверка принадлежности к классу
В Java можно явно проверить, к какому классу принадлежит объект. Выражение foo instanceof Foo равно true, если объект foo принадлежит классу Foo или его наследнику, или реализует интерфейс Foo (или, в общем виде, наследует класс, который реализует интерфейс, который наследует Foo).

Далее функция getClass()[док. 10], определённая для всех объектов, выдаёт объект типа Class<?>. Для каждого класса создаётся не более одного описывающего его объекта типа Class, поэтому эти объекты можно сравнивать. Так, например, foo.getClass() == bar.getClass() будет истинно, если объекты foo и bar принадлежат к одному классу.

Кроме того, объект типа Class<?> любого типа можно получить так: Integer.class, Object.class.

Прямое сравнение классов не всегда является оптимальным средством проверки на принадлежность к классу. Зачастую вместо него используют функцию isAssignableFrom(). Эта функция определена у объекта типа Class и принимает объект типа Class<?> в качестве параметра. Таким образом, вызов Foo.class.isAssignableFrom(Bar.class) вернёт true в случае, если Foo является предком класса Bar. Так как все объекты являются потомками типа Object, вызов Object.class.isAssignableFrom() всегда вернёт true.

В паре с упомянутыми функциями объекта типа Class используются также функции isInstance[док. 11] (эквивалентно instanceof), а также cast() (преобразует параметр в объект выбранного класса).

Обработка ошибок
Обработка ошибок в Java похожа на обработку ошибок в C++ за исключением необходимости в блоке finally. Данное отличие обусловлено тем, что Java не может придерживаться концепции RAII из-за наличия сборщика мусора, а автоматическое освобождение ресурсов в деструкторе может идти в непредсказуемом порядке через произвольные промежутки времени.

Осуществляется обработка ошибок с помощью операторов try, catch и finally. Выбрасываемая ошибка описывается объектом определённого класса, наследующегося от Throwable[док. 12] и соответствующего типу ошибки. Внутрь блока try помещается код, который может выбросить исключение, а блок catch отлавливает заданные программистом типы ошибок. При этом можно указывать более одного блока catch для обработки различных классов ошибок, или multi-catch для обработки нескольких ошибок. Блок finally является необязательным, но при наличии выполняется независимо от возникновения ошибки и предназначен для освобождения выделенных в ходе работы блока try ресурсов.

Начиная с Java 7 поддерживается интерфейс AutoCloseable[док. 13], который позволяет реализовывать классы, автоматически освобождающие ресурсы. Объекты подобных классов требуется создавать в круглых скобках перед блоком try. Простым примером автоматического освобождения ресурсом может служить чтение содержимого файла:

import java.io.*;

public class Main {
    public static void main(String[] args) throws IOException {
        if (args.length < 2) {
            System.err.println("Не указано имя файла.");
            return;
        }
        String filename = args[1];
        // Открытый файл будет автоматически закрыт по ошибке
        try (BufferedReader reader = new BufferedReader(new FileReader(filename))) {
            String line;
            for (int n = 1; (line = reader.readLine()) != null; ++n) {
                System.out.println(n + ": " + line);
            }
        } catch (FileNotFoundException e) {
            System.err.println("Указанный файл не найден.");
        }
        // finally {
        //     reader.close(); // автоматическое закрытие ресурса
        // }
    }
}
Java придерживается концепции обязательного указания классов ошибок, которые может выбросить метод. Делается это с помощью ключевого слова throws после описания метода. Если в методе не указать класс исключения (или его предка), которое может быть выброшено из метода, то это вызовет ошибку компиляции. Концепция должна была позволить делать код самодокументируемым, обозначая, какие исключения может выбросить тот или иной метод, но на практике редко себя оправдывает, поскольку в силу разных обстоятельств программист может указать в качестве выбрасываемого исключения класс Exception либо заключить проблемные части метода в блок try…catch для игнорирования отдельных ошибок, либо — в блок try…finally, скрывая все возможные ошибки. Недостатком концепции также является и то, что программист сам должен определять и прописывать исключения, которые может выбрасывать метод[89].

Пространство имён

Стиль этого раздела неэнциклопедичен или нарушает нормы литературного русского языка.
Статью следует исправить согласно стилистическим правилам Википедии.
Основная статья: Пространство имён (программирование)
Идея пространств имён воплощена в Java-пакетах.

Название Java-пакета — латиница (нижний и верхний регистр) с цифрами (не первые в строке) и знаком подчёркивания (не первые и не последние), не являющаяся инструкциями языка (прим. if, null), разделённая точками.

Правильные примеры названий:

project.types.net.media
a0.a_b.canrepeat.canrepeat.UPPERCASE.RaNdOmCaSe (хотя нежелательно, из-за нечитабельности)
Неправильные примеры названий:

doubledots..something (две точки подряд)
нестандартный.язык (не латиница)
0first.characret.is.number (число в начале)
contains.white space (пробел)
true.asd (содержит true, см. выше)
Пакеты содержат классы, интерфейсы, перечисления, аннотации (и т. д.), имена которых — латиница (нижний и верхний регистр) с цифрами (не первые в строке). Публичный класс, интерфейс (и т. д.) в одном файле может быть только один. Имя публичного класса, интерфейса (и т. д.) в файле должно совпадать с названием файла. Каждый класс имеет своё пространство имён для функций, переменных и подклассов, подинтерфейсов (и т. д.), причём получить подкласс класса можно с помощью OuterClass.InnerClass, а можно с помощью OuterClass$InnerClass, поэтому использование символа доллара в названии класса не рекомендуется.

Примеры программ
Код программы «Hello, world!».

class HelloWorld {
    public static void main(String[] args) {
        System.out.println("Hello, world!");
    }
}
Обобщения:

Пример использования обобщений
Рефлексия:

Пример использования рефлексии
Аннотации:

Пример использования аннотаций
Средства разработки ПО
JDK — помимо набора библиотек для платформ Java SE и Java EE, содержит компилятор командной строки javac и набор утилит, так же работающих в режиме командной строки.
NetBeans IDE — свободная интегрированная среда разработки для всех платформ Java — Java ME, Java SE и Java EE. Пропагандируется Oracle, владельцем технологии Java, как базовое средство для разработки ПО на языке Java и других языках (C, C++, PHP, Fortran и др.).
Eclipse IDE — свободная интегрированная среда разработки для Java SE, Java EE и Java ME[90]. Пропагандируется IBM, одним из важнейших разработчиков корпоративного ПО, как базовое средство для разработки ПО на языке Java и других языках (C, C++, Ruby, Fortran и др.).
IntelliJ IDEA — среда разработки для платформ Java SE, Java EE и Java ME. Разработчик — компания JetBrains. Распространяется в двух версиях: свободной бесплатной (Community Edition) и коммерческой проприетарной (Ultimate Edition).
JDeveloper — среда разработки для платформ Java SE, Java EE и Java ME. Разработчик — компания Oracle.
BlueJ — среда разработки программного обеспечения на языке Java, созданная в основном для использования в обучении, но также подходящая для разработки небольших программ.
Geany — свободная среда разработки программного обеспечения, написанная с использованием библиотеки GTK2.
См. также
В родственных проектах

Значения в Викисловаре

Книги в Викиучебнике

Медиафайлы на Викискладе
Сравнение C# и Java
Список Java API
Java User Groups
Примечания
Комментарии
 Произносится на английском как /ˈdʒɑːvə/, в русском языке встречаются транслитерации «Джава» и «Ява», правообладатели торговой марки предпочитают первую транслитерацию.
Документация
 String
 AutoCloseable
 URLClassLoader
 HttpURLConnection
 StringBuffer
 Void
 clone()
 Cloneable
 Math
 getClass()
 isInstance()
 Throwable
 AutoCloseable
Источники
↑ Показать компактно
 https://www.oracle.com/java/
 JDK 22 Release Notes.
 https://www.lemondeinformatique.fr/actualites/lire-java-open-source-c-est-fait-et-c-est-en-gpl-21350.html
 "Top Programming Languages 2020". IEEE Spectrum (англ.). Архивировано 18 января 2021. Дата обращения: 14 февраля 2021.
 TIOBE Index | TIOBE — The Software Quality Company. www.tiobe.com. Дата обращения: 19 ноября 2018. Архивировано 25 февраля 2018 года.
 Buyya. Object-oriented Programming with Java: Essentials and Applications. — Tata McGraw-Hill Education, 2009. — 678 с. — ISBN 9780070669086. Архивировано 12 ноября 2018 года.
 Star7: с чего начиналась Java. Дата обращения: 2 октября 2022. Архивировано 2 октября 2022 года.
 Java 6 -server speed ÷ C++ GNU g++ speed | Computer Language Benchmarks Game. Дата обращения: 4 марта 2010. Архивировано из оригинала 14 июня 2011 года.
 Metz, Cade. Google pits C++ against Java, Scala, and Go (англ.). The Register (3 июня 2011). Дата обращения: 5 июня 2011. Архивировано 21 августа 2011 года.
 Loop Recognition in C++/Java/Go/Scala (0.3 МБ) Архивная копия от 16 ноября 2011 на Wayback Machine
 В Google провели сравнение производительности C++, Java, Go и Scala. Дата обращения: 5 июня 2011. Архивировано 8 июня 2011 года.
 Robert Tolksdorf. Programming languages for the Java Virtual Machine JVM (англ.). is-research GmbH. — Онлайн-каталог альтернативных языков и языковых расширений для JVM. Дата обращения: 5 июня 2009. Архивировано 21 августа 2011 года.
 SUN SHIPS JDK 1.1 -- JAVABEANS INCLUDED (10 февраля 2008). Дата обращения: 17 ноября 2018. Архивировано 10 февраля 2008 года.
 Java 2 Software (19 января 2004). Дата обращения: 17 ноября 2018. Архивировано 19 января 2004 года.
 Ada 83 LRM, Sec 12.1: Generic Declarations. archive.adaic.com. Дата обращения: 17 ноября 2018. Архивировано 17 апреля 2019 года.
 Collections Framework Enhancements. oracle.com. Дата обращения: 12 сентября 2023. Архивировано 25 ноября 2023 года.
 Результаты тестов. Дата обращения: 13 сентября 2012. Архивировано 25 июня 2012 года.
 JavaFX FAQ. www.oracle.com. Дата обращения: 17 ноября 2018. Архивировано 29 октября 2018 года.
 Smith, Donald. "The Future of JavaFX and Other Java Client Roadmap Updates". Архивировано 17 ноября 2018. Дата обращения: 17 ноября 2018.
 план разработки для JDK7. Дата обращения: 4 июля 2011. Архивировано 8 января 2021 года.
 План Б. Дата обращения: 4 июля 2011. Архивировано 11 июля 2011 года.
 OpenJDK: Project Coin. openjdk.java.net. Дата обращения: 17 ноября 2018. Архивировано 4 октября 2012 года.
 Компания Oracle анонсировала выход Java Standard Edition 7 Архивная копия от 3 августа 2011 на Wayback Machine (рус.)
 Index corruption and crashes in Apache Lucene Core / Apache Solr with Java 7 Архивная копия от 9 августа 2021 на Wayback Machine (англ.)
 Акторное расширение языка Java в среде MPS Архивная копия от 29 апреля 2015 на Wayback Machine. — вестник ИТМО. — Вып 6 (94)
 What's New in JDK 8. www.oracle.com. Дата обращения: 17 ноября 2018. Архивировано 13 апреля 2020 года.
 Method References (англ.). The Java™ Tutorials. docs.oracle.com. Дата обращения: 17 ноября 2018. Архивировано 21 октября 2018 года.
 JDK 9 release delayed another four months. Дата обращения: 17 мая 2017. Архивировано 9 мая 2017 года.
 Java 9 gets a release date: July 27. Дата обращения: 17 мая 2017. Архивировано 17 мая 2017 года.
 Java 9 delayed to September 21. Дата обращения: 29 июля 2017. Архивировано 29 июля 2017 года.
 Oracle Announces Java SE 9 and Java EE 8. Press Release (англ.). Oracle (21 сентября 2017). Дата обращения: 1 августа 2018. Архивировано 2 октября 2018 года.
 Project Jigsaw (англ.). openjdk.java.net. Дата обращения: 24 ноября 2018. Архивировано 9 января 2021 года.
 JEP 102: Process API Updates (англ.). OpenJDK. Дата обращения: 6 сентября 2018. Архивировано 6 сентября 2018 года.
 JEP 110: HTTP/2 Client (Incubator) (англ.). OpenJDK. Дата обращения: 6 сентября 2018. Архивировано 2 сентября 2018 года.
 JEP 11: Incubator Modules (англ.). OpenJDK. Дата обращения: 6 сентября 2018. Архивировано 15 сентября 2018 года.
 JEP 254: Compact Strings (англ.). OpenJDK. Дата обращения: 6 сентября 2018. Архивировано 8 сентября 2018 года.
 JEP 287: SHA-3 Hash Algorithms (англ.). OpenJDK. Дата обращения: 6 сентября 2018. Архивировано 6 сентября 2018 года.
 JEP 277: Enhanced Deprecation (англ.). OpenJDK. Дата обращения: 6 сентября 2018. Архивировано 19 сентября 2018 года.
 Java Language Updates. www.oracle.com. Дата обращения: 14 ноября 2021. Архивировано 14 ноября 2021 года.
 JEP 283: Enable GTK 3 on Linux. openjdk.java.net. Дата обращения: 25 ноября 2018. Архивировано 24 ноября 2018 года.
 Oracle Java SE 10 Release Arrives (англ.). ORACLE. Дата обращения: 24 июня 2018. Архивировано 20 марта 2018 года.
 JEP 286: Local-Variable Type Inference (англ.). openjdk.java.net. Дата обращения: 18 ноября 2018. Архивировано 18 ноября 2018 года.
 JEP 304: Garbage Collector Interface (англ.). openjdk.java.net. Дата обращения: 20 ноября 2018. Архивировано 3 октября 2018 года.
 JEP 307: Parallel Full GC for G1 (англ.). openjdk.java.net. Дата обращения: 21 ноября 2018. Архивировано 3 октября 2018 года.
 Алексей Рагозин. Safepoints in HotSpot JVM (англ.). blog.ragozin.info. Дата обращения: 24 ноября 2018. Архивировано 24 ноября 2018 года.
 JEP 312: Thread-Local Handshakes (англ.). openjdk.java.net. Дата обращения: 24 ноября 2018. Архивировано 21 октября 2018 года.
 JEP 314: Additional Unicode Language-Tag Extensions (англ.). openjdk.java.net. Дата обращения: 22 ноября 2018. Архивировано 5 октября 2018 года.
 JEP 316: Heap Allocation on Alternative Memory Devices (англ.). openjdk.java.net. Дата обращения: 24 ноября 2018. Архивировано 22 октября 2018 года.
 JEP 317: Experimental Java-Based JIT Compiler (англ.). openjdk.java.net. Дата обращения: 22 ноября 2018. Архивировано 24 ноября 2018 года.
 JEP 322: Time-Based Release Versioning (англ.). openjdk.java.net. Дата обращения: 22 ноября 2018. Архивировано 31 октября 2018 года.
 JEP 181: Nest-Based Access Control (англ.). openjdk.java.net. Дата обращения: 18 ноября 2018. Архивировано 18 ноября 2018 года.
 JEP 318: Epsilon: A No-Op Garbage Collector (Experimental) (англ.). openjdk.java.net. Дата обращения: 18 ноября 2018. Архивировано 18 ноября 2018 года.
 JEP 321: HTTP Client (Standard) (англ.). openjdk.java.net. Дата обращения: 18 ноября 2018. Архивировано 24 ноября 2018 года.
 JEP 323: Local-Variable Syntax for Lambda Parameters (англ.). openjdk.java.net. Дата обращения: 18 ноября 2018. Архивировано 15 ноября 2018 года.
 JEP 327: Unicode 10 (англ.). openjdk.java.net. Дата обращения: 18 ноября 2018. Архивировано 18 ноября 2018 года.
 JEP 332: Transport Layer Security (TLS) 1.3 (англ.). openjdk.java.net. Дата обращения: 18 ноября 2018. Архивировано 18 ноября 2018 года.
 JEP 333: ZGC: A Scalable Low-Latency Garbage Collector (Experimental) (англ.). openjdk.java.net. Дата обращения: 18 ноября 2018. Архивировано 18 ноября 2018 года.
 JDK 12 Release Notes. Дата обращения: 24 сентября 2023. Архивировано 27 сентября 2023 года.
 JDK Releases. Дата обращения: 16 января 2024. Архивировано 4 июня 2022 года.
 JDK 13 Release Notes. Дата обращения: 16 января 2024. Архивировано 16 января 2024 года.
 Consolidated JDK 14 Release Notes. Дата обращения: 16 января 2024. Архивировано 16 января 2024 года.
 JDK 15 Release Notes. Дата обращения: 16 января 2024. Архивировано 16 января 2024 года.
 JDK 16 Release Notes. Дата обращения: 16 января 2024. Архивировано 16 января 2024 года.
 Consolidated JDK 17 Release Notes. Дата обращения: 16 января 2024. Архивировано 16 января 2024 года.
 JDK 18 Release Notes. Дата обращения: 16 января 2024. Архивировано 18 апреля 2023 года.
 JDK 19 Release Notes. Дата обращения: 16 января 2024. Архивировано 20 сентября 2023 года.
 JDK 20 Release Notes. Дата обращения: 16 января 2024. Архивировано 12 сентября 2023 года.
 JDK 21 Release Notes. Дата обращения: 16 января 2024. Архивировано 16 января 2024 года.
 Delabassee, David. "Opening Up Java EE - An Update". Архивировано 26 ноября 2018. Дата обращения: 25 ноября 2018.
 "And the Name Is…". Life at Eclipse (англ.). 2018-02-26. Архивировано 26 ноября 2018. Дата обращения: 25 ноября 2018.
 JEP 320: Remove the Java EE and CORBA Modules. openjdk.java.net. Дата обращения: 25 ноября 2018. Архивировано 24 ноября 2018 года.
 Microsoft Java Virtual Machine Support (англ.). Microsoft (12 сентября 2003). — Официальное заявление Microsoft о программе поддержки MSJVM. Дата обращения: 9 октября 2010. Архивировано 21 августа 2011 года.
 Visual J#. Microsoft (ноябрь 2007). — Официальная информация Microsoft об исключении J# из комплекта Visual Studio 2008. Дата обращения: 10 октября 2010. Архивировано 21 августа 2011 года.
 Todd Hoff. Amazon Architecture (англ.) (18 сентября 2007). — Обсуждение архитектуры Amazon с использованием Java-технологий. Дата обращения: 6 июня 2009. Архивировано 28 февраля 2009 года.
 Amazon Elastic Compute Cloud (Amazon EC2) (англ.). Amazon Web Services LLC. — Описание технологии и возможностей Amazon EC2 как веб-сервиса. Дата обращения: 6 июня 2009. Архивировано 21 августа 2011 года.
 Todd Hoff. eBay Architecture (англ.) (27 мая 2008). — Обсуждение архитектуры eBay на платформе Java. Дата обращения: 6 сентября 2009. Архивировано 21 августа 2011 года.
 Randy Shoup, Dan Pritchett. The eBay Architecture (англ.). SD Forum 2006. ??? (29 ноября 2006). — Презентация по истории развития архитектуры eBay. Дата обращения: 6 июня 2009. Архивировано 21 августа 2011 года.
 Brian Guan. The LinkedIn Blog. Blog Archive. Grails at LinkedIn (англ.). LinkedIn.com (11 июня 2008). — История создания системы LinkedIn на основе Java-технологии Grails. Дата обращения: 5 июня 2009. Архивировано 21 августа 2011 года.
 Hadoop and Distributed Computing at Yahoo! (англ.). Yahoo!. — Стартовая страница Java-технологии распределённого обслуживания Hadoop на портале разработчиков Yahoo! Дата обращения: 21 июня 2009. Архивировано 21 августа 2011 года.
 OracleJVM and Java Stored Procedures (англ.). Oracle Inc.. — Раздел портала Oracle, посвящённый технологиям Java в составе сервера СУБД Oracle. Дата обращения: 5 июня 2009. Архивировано 21 августа 2011 года.
 Ubuntu: Intel® Q6600® quad-core Computer Language Benchmarks. Архивировано 22 июня 2012 года.
 Wolfgang Puffitsch, Martin Schoeberl. picoJava-II in an FPGA (англ.) // DTU Library. — 2007. Архивировано 2 декабря 2018 года.
 JVM не имеет поддержки для переменных типа boolean, поэтому они представляются в виде значений типа int. Однако массивы boolean[] поддерживаются. VM Spec The Structure of the Java Virtual Machine Архивная копия от 24 ноября 2011 на Wayback Machine
 JEP 306: Restore Always-Strict Floating-Point Semantics (англ.). Дата обращения: 21 ноября 2022. Архивировано 21 ноября 2022 года.
 Бьярн Страуструп. Язык программирования C++ = The C++ Programming Language. — М.—СПб.: Бином, Невский диалект, 2008. — 1104 с. — 5000 экз. — ISBN 5-7989-0226-2; ISBN 5-7940-0064-3; ISBN 0-201-70073-5.
 Джеймс Гослинг, Билл Джой, Гай Стил, Гилад Брача, Алекс Бакли, Даниел Смит. Java Language Specification. Chapter 15. Expressions (англ.). docs.oracle.com. Дата обращения: 1 декабря 2018. Архивировано 1 декабря 2018 года.
 Java API Reference. Class Object (англ.). docs.oracle.com. Дата обращения: 26 ноября 2018. Архивировано 26 ноября 2018 года.
 Scott Oaks. Java Performance: The Definitive Guide: Getting the Most Out of Your Code. — "O'Reilly Media, Inc.", 2014-04-10. — 425 с. — ISBN 9781449363543. Архивировано 21 июля 2021 года.
 The Trouble with Checked Exceptions. www.artima.com. Дата обращения: 21 декабря 2018. Архивировано 8 января 2019 года.
 Pulsar - Eclipse Mobile Tools Platform (англ.). Eclipse. — Проект eclipse для мобильных разработчиков. Дата обращения: 23 марта 2011. Архивировано 21 августа 2011 года.
Литература
Герберт Шилдт. Java. Полное руководство, 10-е издание = Java. The Complete Reference, 10th Edition. — М.: «Диалектика», 2018. — 1488 с. — ISBN 978-5-6040043-6-4.
Кей С. Хорстманн. Java SE 9. Базовый курс = Core Java SE 9 for the Impatient. — М.: «Вильямс», 2018. — 576 с. — ISBN 978-5-6040043-0-2, 978-0-13-469472-6.
Кей С. Хорстманн. Java SE 8. Вводный курс = Java SE 8 for the Really Impatient. — М.: «Вильямс», 2014. — 208 с. — ISBN 978-5-8459-1900-7.
Фрэд Лонг, Дхрув Мохиндра, Роберт С. Сикорд, Дин Ф. Сазерленд, Дэвид Свобода. Руководство для программиста на Java: 75 рекомендаций по написанию надёжных и защищённых программ = Java Coding Guidelines: 75 Recommendations for Reliable and Secure Programs. — М.: «Вильямс», 2014. — 256 с. — ISBN 978-5-8459-1897-0.
Кей С. Хорстманн. Java. Библиотека профессионала, том 1. Основы. 10-е издание = Core Java. Volume I - Fundamentals (Tenth Edition). — М.: «Вильямс», 2017. — 864 с. — ISBN 978-5-8459-2084-3.
Кей С. Хорстманн. Java. Библиотека профессионала, том 2. Расширенные средства программирования. 10-е издание = Core Java. Volume II - Advanced Feature (Tenth Edition). — М.: «Вильямс», 2017. — 976 с. — ISBN 978-5-9909445-0-3.
Барри Берд. Java 9 для чайников = Java For Dummies, 7th edition. — М.: «Диалектика», 2018. — 624 с. — ISBN 978-5-9500296-1-5, 978-1-119-23555-2.
Кишори Шаран. Java 9. Полный обзор нововведений = Java 9 Revealed. — М.: «ДМК Пресс», 2018. — 544 с. — ISBN 978-5-97060-575-2.
Джеймс Гослинг, Билл Джой, Гай Стил, Гилад Брача, Алекс Бакли. Язык программирования Java SE 8. Подробное описание, 5-е издание = The Java Language Specification, Java SE 8 Edition (5th Edition) (Java Series). — М.: «Вильямс», 2015. — 672 с. — ISBN 978-5-8459-1875-8.
Джошуа Блох. Java. Эффективное программирование = Effective Java. — 3-е. — М.: Диалектика, 2019. — 464 с. — ISBN 978-5-6041394-4-8.
Бенджамин Дж. Эванс, Джеймс Гоф, Крис Ньюленд. Java: оптимизация программ. Практические методы повышения производительности приложений в JVM. — М.: Диалектика, 2019. — 448 с. — ISBN 978-5-907114-84-5.
Монахов Вадим. Язык программирования Java и среда NetBeans. — 3-е изд. — СПб.: БХВ-Петербург, 2011. — 704 с. — ISBN 978-5-9775-0671-7.
Брюс Эккель. Философия Java = Thinking in Java. — 4-е изд. — СПб.: Питер, 2018. — 1168 с. — ISBN 978-5-496-01127-3.
Ссылки
The Java Tutorials (англ.) — обучающие материалы по Java 8
Bruce Eckel’s Free Electronic Books (англ.) — свободно распространяемые электронные версии книг Брюса Эккеля по C++ и Java вместе с исходным кодом
Учебник Java 8
Официальный сайт Java
Перейти к шаблону «Внешние ссылки» Перейти к элементу Викиданных  В социальных сетях
Твиттер
Тематические сайты
Open Hub
Словари и энциклопедии
Большая китайскаяБольшая норвежскаяBritannica (онлайн)Treccani
В библиографических каталогах
Перейти к шаблону «Java»
Java
Перейти к шаблону «Языки программирования»
Языки программирования
Категории: Языки программирования по алфавитуЯзыки программирования, появившиеся в 1995 годуJavaЯзыки веб-программированияЯзыки программирования с автоматическим управлением памятью
Навигация
Вы не представились системе
Обсуждение
Вклад
Создать учётную запись
Войти
СтатьяОбсуждение
ЧитатьТекущая версияПравитьПравить кодИсторияПоиск
Искать в Википедии
Заглавная страница
Содержание
Избранные статьи
Случайная статья
Текущие события
Пожертвовать
Участие
Сообщить об ошибке
Как править статьи
Сообщество
Форум
Свежие правки
Новые страницы
Справка
Инструменты
Ссылки сюда
Связанные правки
Служебные страницы
Постоянная ссылка
Сведения о странице
Цитировать страницу
Получить короткий URL
Скачать QR-код
Развернуть всё
Печать/экспорт
Скачать как PDF
Версия для печати
В других проектах
Викисклад
Викиучебник
Викиновости
Элемент Викиданных

На других языках
Azərbaycanca
Чӑвашла
English
Suomi
Հայերեն
Монгол
Саха тыла
Српски / srpski
Татарча / tatarça
Ещё 107
Править ссылки
Эта страница в последний раз была отредактирована 20 мая 2024 в 16:35.
Текст доступен по лицензии Creative Commons «С указанием авторства — С сохранением условий» (CC BY-SA); в отдельных случаях могут действовать дополнительные условия. Подробнее см. Условия использования.
Wikipedia® — зарегистрированный товарный знак некоммерческой организации «Фонд Викимедиа» (Wikimedia Foundation, Inc.)
Политика конфиденциальностиОписание ВикипедииОтказ от ответственностиСвяжитесь с намиКодекс поведенияРазработчикиСтатистикаЗаявление о кукиМобильная версияWikimedia FoundationPowered by MediaWiki